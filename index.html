<!doctype html>
<html lang="en">

  <head>
    <title>Lambda Lists - Building Scheme-like lists in vanilla JS</title>
    <meta charset="utf-8">
    <meta name="description" content="Lists with a lisp, using closures. Inspired by http://stevelosh.com/blog/2013/03/list-out-of-lambda/.">
    <meta name="author" content="Derek Pennycuff">
    <style>
        /**/
    </style>
  </head>
  <body>
    <p>The fun stuff is in the console.</p>
  </body>
  <script>
    /** 
     * Version 1 covers the first half or so of the original article. 
     * Wrapping everything in an object literal complicates some things
     * but since I'm writing this in 2018 I can use stuff like arrow functions
     * to help make up for the added verbosity in places.
     */
    const lambdaList1 = function() {
        const empty_list = Symbol('empty_list');
        return {
            make: () => empty_list,
            prepend: (element, list) => (cmd) => (cmd === 'head') ? element : list,
            head: (list) => list('head'),
            tail: (list) => list('tail'),
            is_empty: (list) => list === empty_list,
        }
    };
    /**
     * Version 2 drops the need for is checks and string literals (or
     * Symbols, as my version 1 used in place of the null representing
     * an empty list in the source article). This one gets a little
     * brain melty if we don't have our sea legs for higher order
     * functions. After years of dabbling in this stuff I'm still not
     * sure I've got my sea legs, so I will attempt to briefly explain
     * if only for the benefit of my future self.
     *
     * Each item of our list can be thought of as consisting of 3
     * fields: an element currently at the head of our list, the
     * tail of the current list (which is itself a list), and a boolean
     * representing if we have reached the end of our list.
     *
     * Only the empty list will have TRUE for that 3rd field. And the
     * other 2 fields do not matter for the empty list as we should
     * never actually access them. We are using `undefined` here but
     * we could have used null or a symbol or whatever reasonable value
     * we want. As we build a list with calls to prepend() we always
     * set the 3rd field to FALSE.
     *
     * Calls to prepend() also wrap the element being appended and the
     * list being appended to in a closure. This closure expects to be given a
     * selector function to access one of our three fields. So now our calls to
     * head(), tail(), and is_empty() can invoke the closure and pass along a
     * selector function to access the first, second, or third field as needed.
     * Here we are using anonymous arrow functions but the implementation
     * details can safely be ignored by the rest of our code.
     */
    const lambdaList2 = function() {
        const empty_list = (sel) => sel(undefined, undefined, true);
        return {
            make: () => empty_list,
            prepend: (element, list) => (sel) => sel(element, list, false),
            head: (list) => list((h, t, e) => h),
            tail: (list) => list((h, t, e) => t),
            is_empty: (list) => list((h, t, e) => e),
        }
    };

    const listDecorator = function(lambdaList) {
        const not = (x) => (x) ? false : true;
        const and = (a, b) => (a) ? (b) ? true : false : false;
        const or = (a, b) => (a) ? true : (b) ? true : false;
        const xor = (a, b) => and(or(a, b), not(and(a, b)));
        lambdaList.map = function(func, list) {
            if (this.is_empty(list)) {
                return this.make();
            } else {
                return this.prepend(
                    func(this.head(list)),
                    this.map(
                        func, 
                        this.tail(list)
                    )
                );
            }
        }
        lambdaList.filter = function(func, list) {
            if (this.is_empty(list)) {
                return this.make();
            } else if (func(this.head(list))) {
                return this.prepend(
                    this.head(list),
                    this.filter(
                        func,
                        this.tail(list)
                    )
                );
            } else {
                return this.filter(
                    func,
                    this.tail(list)
                );
            }
        }
        lambdaList.notTest = (x) => not(x);
        lambdaList.andTest = (a, b) => and(a, b);
        lambdaList.orTest = (a, b) => or(a, b);
        lambdaList.xorTest = (a, b) => xor(a, b);

        return lambdaList;
    }

    const churchNumbers = function(lambdaList) {
        const zero = lambdaList.make();
        const one = lambdaList.prepend(zero, zero);
        const two = lambdaList.prepend(zero, one);
        lambdaList.is_zero = function(n) {
            return this.is_empty(n);
        }
        lambdaList.inc = function(n) {
            return this.prepend(zero, n);
        }
        lambdaList.dec = function(n) {
            return this.is_zero(n) ? zero : this.tail(n);
        }
        lambdaList.add = function(a, b) {
            return (this.is_zero(b))? a : this.add(this.inc(a), this.dec(b));
        }
        lambdaList.sub = function(a, b) {
            return (this.is_zero(b))? a : this.sub(this.dec(a), this.dec(b));
        }
        lambdaList.mul = function(a, b) {
            return (this.is_zero(b))? zero : this.add(a, this.mul(a, this.dec(b)));
        }
        lambdaList.pow = function(a, b) {
            return (this.is_zero(b))? one : this.mul(a, this.pow(a, this.dec(b)));
        }
        lambdaList.is_equal = function(a, b) {
            if (this.andTest(this.is_zero(a), this.is_zero(b))) {
                return true;
            } else if (this.orTest(this.is_zero(a), this.is_zero(b))) {
                return false;
            } else {
                return this.is_equal(this.dec(a), this.dec(b));
            }
        }
        lambdaList.lt = function(a, b) {
            if (this.andTest(this.is_zero(a), this.is_zero(b))) {
                return false;
            } else if (this.is_zero(a)) {
                return true;
            } else if (this.is_zero(b)) {
                return false;
            } else {
                return this.lt(this.dec(a), this.dec(b));
            }
        }
        lambdaList.gt = function(a, b) {
            return this.lt(b, a);
        }
        lambdaList.div = function(a, b) {
            return this.lt(a, b) ? zero : this.inc(this.div(this.sub(a, b), b));
        }
        lambdaList.rem = function(a, b) {
            return this.lt(a, b) ? a : this.rem(this.sub(a, b), b);
        }
        lambdaList.toInt = function(list) {
            return this.is_zero(list) ? 0 : 1 + this.toInt(this.tail(list));
        }
        lambdaList.fromInt = function(n) {
            const num = parseInt(n, 10);
            return (num === 0 || num < 0 || Number.isNaN(num)) ? zero : this.prepend(zero, this.fromInt(n - 1));
        }

        return lambdaList;
    }

    const arrayDecorator = function(churchList) {
        churchList.nth = function(list, n) {
            return this.is_zero(n) ? this.head(list) : this.nth(this.tail(list, this.dec(n)));
        }
        churchList.drop = function(list, n) {
            return this.is_zero(n) ? list : this.drop(this.tail(list), this.dec(n));
        }
        churchList.take = function(list, n) {
            return this.is_zero(n) ? zero : this.prepend(this.head(list), this.take(this.tail(list), this.dec(n)));
        }
        churchList.slice = function(list, start, end) {
            return this.take(this.drop(list, start), this.sub(end, start));
        }
        churchList.length = function(list) {
            return this.is_zero(list) ? zero : this.inc(this.length(this.tail(list)));
        }
    }

    const square = (x) => x * x;
    const is_odd = (x) => x % 2 === 1;
    const listTest = function(testList) {
        const e = testList.make();
        console.log('Test empty list and is_empty() method');
        console.log(testList.is_empty(e)); // true
        console.log("^ true");
        console.assert(testList.is_empty(e) === true);

        console.log('Test basic list construction and item access');
        const names = testList.prepend(
            "Alice",
            testList.prepend(
                "Bob",
                testList.prepend(
                    "Candice",
                    e
                )
            )
        );
        console.log(testList.is_empty(names)); // false
        console.log("^ false");
        console.assert(testList.is_empty(names) === false);
        console.log(testList.head(names)); // "Alice"
        console.log("^ 'Alice'");
        console.assert(testList.head(names) === 'Alice');
        console.log(testList.tail(names)); // Closure for ["Bob", "Candice"]
        console.log("^ Closure");
        console.log(testList.head(testList.tail(names))); // "Bob"
        console.log("^ 'Bob'");
        console.assert(testList.head(testList.tail(names)) === 'Bob');

        console.log('Test map() method')
        const numbers = testList.prepend(
            1,
            testList.prepend(
                2,
                testList.prepend(
                    3,
                    e
                )
            )
        );
        const squared_numbers = testList.map(square, numbers);
        console.log(testList.head(testList.tail(testList.tail(squared_numbers)))); // 9
        console.log("^ 9");
        console.assert(testList.head(testList.tail(testList.tail(squared_numbers))) === 9);

        console.log('Test filter() method');
        const odd_numbers = testList.filter(is_odd, numbers);
        console.log(testList.head(odd_numbers)); // 1
        console.log("^ 1");
        console.assert(testList.head(odd_numbers) === 1);
        console.log(testList.head(testList.tail(odd_numbers))); // 3
        console.log("^ 3");
        console.assert(testList.head(testList.tail(odd_numbers)) === 3);

        console.log('Test helper methods');
        console.log(testList.notTest(true)); // false
        console.log("^ false");
        console.assert(testList.notTest(true) === false);

        console.log(testList.notTest(false)); // true
        console.log("^ true");
        console.assert(testList.notTest(false) === true);

        console.log(testList.andTest(true, true)); // true
        console.log("^ true");
        console.assert(testList.andTest(true, true) === true);

        console.log(testList.andTest(true, false)); // false
        console.log("^ false");
        console.assert(testList.andTest(true, false) === false);

        console.log(testList.andTest(false, true)); // false
        console.log("^ false");
        console.assert(testList.andTest(false, true) === false);

        console.log(testList.andTest(false, false)); // false
        console.log("^ false");
        console.assert(testList.andTest(false, false) === false);

        console.log(testList.orTest(true, true)); // true
        console.log("^ true");
        console.assert(testList.orTest(true, true) === true);

        console.log(testList.orTest(true, false)); // true
        console.log("^ true");
        console.assert(testList.orTest(true, false) === true);

        console.log(testList.orTest(false, true)); // true
        console.log("^ true");
        console.assert(testList.orTest(false, true) === true);

        console.log(testList.orTest(false, false)); // false
        console.log("^ false");
        console.assert(testList.orTest(false, false) === false);

        console.log(testList.xorTest(true, true)); // false
        console.log("^ false");
        console.assert(testList.xorTest(true, true) === false);

        console.log(testList.xorTest(true, false)); // true
        console.log("^ true");
        console.assert(testList.xorTest(true, false) === true);

        console.log(testList.xorTest(false, true)); // true
        console.log("^ true");
        console.assert(testList.xorTest(false, true) === true);

        console.log(testList.xorTest(false, false)); // false
        console.log("^ false");
        console.assert(testList.xorTest(false, false) === false);
    }

    const churchTest = function(church) {
        const zero = church.make();
        console.log('Test is_zero()');
        console.log({is_zero: church.is_zero(zero)});
        console.assert(church.is_zero(zero) === true);

        console.log('Test inc()');
        const one = church.inc(zero);
        const two = church.inc(one);
        const three = church.inc(two);
        const four = church.inc(three);
        const five = church.inc(four);
        const six = church.inc(five);
        const seven = church.inc(six);
        const eight = church.inc(seven);
        const nine = church.inc(eight);
        const ten = church.inc(nine);
        console.log({three: church.toInt(three)});
        console.log({zero_inc_inc_inc: church.toInt(church.inc(church.inc(church.inc(zero))))});
        console.assert(church.toInt(three) === church.toInt(church.inc(church.inc(church.inc(zero)))));

        console.log('Test dec()');
        console.log({one: church.toInt(one)});
        console.log({three_dec_dec: church.toInt(church.dec(church.dec(three)))});
        console.assert(church.toInt(one) === church.toInt(church.dec(church.dec(three))));

        console.log('Test add()');
        console.log({five_toInt: church.toInt(five)});
        console.log({two_plus_three_toInt: church.toInt(church.add(two, three))});
        console.log({zero_plus_five_toInt: church.toInt(church.add(zero, five))});
        console.log({five_plus_zero_toInt: church.toInt(church.add(five, zero))});
        console.assert(church.toInt(five) === church.toInt(church.add(two, three)));
        console.assert(church.toInt(five) === church.toInt(church.add(zero, five)));
        console.assert(church.toInt(five) === church.toInt(church.add(five, zero)));
        console.assert(church.toInt(church.add(zero, five)) === church.toInt(church.add(five, zero)));

        console.log('Test sub()');
        console.log({six_toInt: church.toInt(six)});
        console.log({eight_sub_two_toInt: church.toInt(church.sub(eight, two))});
        console.log({zero_sub_six_toInt: church.toInt(church.sub(zero, six))});
        console.log({six_sub_zero_toInt: church.toInt(church.sub(six, zero))});
        console.assert(church.toInt(six) === church.toInt(church.sub(eight, two)));
        console.assert(church.toInt(six) === church.toInt(church.sub(six, zero)));
        console.assert(church.toInt(zero) === church.toInt(church.sub(zero, six)));

        console.log('Test mul()');
        console.log({eight_toInt: church.toInt(eight)});
        console.log({four_x_two_toInt: church.toInt(church.mul(four, two))});
        console.log({two_x_four_toInt: church.toInt(church.mul(two, four))});
        console.assert(church.toInt(eight) === church.toInt(church.mul(four, two)));
        console.assert(church.toInt(eight) === church.toInt(church.mul(two, four)));
        console.assert(church.toInt(church.mul(two, four)) === church.toInt(church.mul(four, two)));
        console.log({eight_x_one_toInt: church.toInt(church.mul(eight, one))});
        console.log({one_x_eight_toInt: church.toInt(church.mul(one, eight))});
        console.assert(church.toInt(eight) === church.toInt(church.mul(eight, one)));
        console.assert(church.toInt(eight) === church.toInt(church.mul(one, eight)));
        console.assert(church.toInt(church.mul(eight, one)) === church.toInt(church.mul(one, eight)));
        console.log({eight_x_zero_toInt: church.toInt(church.mul(eight, zero))});
        console.log({zero_x_eight_toInt: church.toInt(church.mul(zero, eight))});
        console.assert(church.toInt(zero) === church.toInt(church.mul(eight, zero)));
        console.assert(church.toInt(zero) === church.toInt(church.mul(zero, eight)));
        console.assert(church.toInt(church.mul(eight, zero)) === church.toInt(church.mul(zero, eight)));

        console.log('Test pow()');
        console.log({four_to_the_two_toInt: church.toInt(church.pow(four, two))});
        console.assert(church.toInt(church.pow(four, two)) === 16);
        console.log({three_to_the_three_toInt: church.toInt(church.pow(three, three))});
        console.assert(church.toInt(church.pow(three, three)) === 27);
        console.log({nine_to_the_zero_toInt: church.toInt(church.pow(nine, zero))});
        console.assert(church.toInt(church.pow(nine, zero)) === church.toInt(one));
        console.log({nine_to_the_one_toInt: church.toInt(church.pow(nine, one))});
        console.assert(church.toInt(church.pow(nine, one)) === church.toInt(nine));
        // 0^0 is technically undefined but defining it to be 1 can be acceptable
        console.log({zero_to_the_zero_toInt: church.toInt(church.pow(zero, zero))});
        console.assert(church.toInt(church.pow(zero, zero)) === 1);
        console.log({zero_to_the_one_toInt: church.toInt(church.pow(zero, one))});
        console.assert(church.toInt(church.pow(zero, one)) === 0);

        console.log('Test is_equal()');
        console.log({two_to_the_three_toInt: church.toInt(church.pow(two, three))});
        console.log({two_to_the_three_equals_eight: church.is_equal(church.pow(two, three), eight)});
        console.assert(church.is_equal(church.pow(two, three), eight));
        console.log({one_equals_one: church.is_equal(one, one)});
        console.assert(church.is_equal(one, one) === true);
        console.log({zero_equals_zero: church.is_equal(zero, zero)});
        console.assert(church.is_equal(zero, zero) === true);
        console.log({one_equals_zero: church.is_equal(one, zero)});
        console.assert(church.is_equal(one, zero) === false);
        console.log({zero_equals_one: church.is_equal(zero, one)});
        console.assert(church.is_equal(zero, one) === false);

        console.log('Test lt()');
        console.log({three_lt_two: church.lt(three, two)});
        console.assert(church.lt(three, two) === false);
        console.log({three_lt_three: church.lt(three, three)});
        console.assert(church.lt(three, three) === false);
        console.log({three_lt_four: church.lt(three, four)});
        console.assert(church.lt(three, four) === true);

        console.log('Test gt()');
        console.log({three_gt_two: church.gt(three, two)});
        console.assert(church.gt(three, two) === true);
        console.log({three_gt_three: church.gt(three, three)});
        console.assert(church.gt(three, three) === false);
        console.log({three_gt_four: church.gt(three, four)});
        console.assert(church.gt(three, four) === false);

        console.log('Test div()');
        console.log({six_div_three_toInt: church.toInt(church.div(six, three))});
        console.assert(church.is_equal(church.div(six, three), two));
        console.log({five_div_three_toInt: church.toInt(church.div(five, three))});
        console.assert(church.is_equal(church.div(five, three), one));
        console.log({two_div_three_toInt: church.toInt(church.div(two, three))});
        console.assert(church.is_equal(church.div(two, three), zero));

        console.log('Test rem()');
        console.log({six_rem_three_toInt: church.toInt(church.rem(six, three))});
        console.assert(church.is_equal(church.rem(six, three), zero) === true);
        console.log({seven_rem_three_toInt: church.toInt(church.rem(seven, three))});
        console.assert(church.is_equal(church.rem(seven, three), one) === true);
        console.log({eight_rem_three_toInt: church.toInt(church.rem(eight, three))});
        console.assert(church.is_equal(church.rem(eight, three), two) === true);
        console.log({nine_rem_three_toInt: church.toInt(church.rem(nine, three))});
        console.assert(church.is_equal(church.rem(nine, three), zero) === true);
    }

    const arrayTest = function(arr) {
        console.log('Test nth()');

        console.log('Test drop()');

        console.log('Test take()');

        console.log('Test slice()');

        console.log('Test length()');
    }

    const ll1 = listDecorator(lambdaList1());
    listTest(ll1);
    const ll2 = listDecorator(lambdaList2());
    listTest(ll2);
    const church1 = churchNumbers(ll1);
    churchTest(church1);
    const church2 = churchNumbers(ll2);
    churchTest(church2);
  </script>
</html>
